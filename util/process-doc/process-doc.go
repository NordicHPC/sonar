// This reads a valid Go package from stdin and extracts some documentation that's written in
// standard godoc format, and generates various output on stdout, depending on options.  A typical
// input file is ../formats/newfmt/types.go.  Typical output is markdown documentation, or field
// name definitions to be used by Rust code.  Try -h.
//
// TODO:
// - obviously it would be fun to hyperlink automatically from uses of types to their definitions
// - consider emitting not string but enums or other type-safer things (see TODO below)
// - proper underline insertion in words like MyCPUAvg which should be MY_CPU_AVG (see TODO below)

package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"regexp"
	"strings"
)

var (
	makeDoc  = flag.Bool("doc", false, "Produce markdown documentation")
	makeRust = flag.Bool("tag", false, "Produce Rust constant JSON field tags")
	warnings = flag.Bool("w", false, "Print warnings")
	fset     = token.NewFileSet()
)

func main() {
	flag.Parse()
	if *makeDoc == *makeRust {
		fmt.Fprintf(os.Stderr, "Must use -doc xor -tag.  Try -h.\n")
		os.Exit(2)
	}
	switch {
	case *makeDoc:
		fmt.Print("# Sonar JSON format output specification\n\n")
		fmt.Print("AUTOMATICALLY GENERATED BY `process-doc`.  DO NOT EDIT.\n")
		fmt.Print("Instead, edit `util/formats/newfmt/types.go`, then in `util/process-doc` run `make install`.\n\n")

	case *makeRust:
		fmt.Print("// AUTOMATICALLY GENERATED BY `process-doc`.  DO NOT EDIT.\n")
		fmt.Print("// Edit `util/formats/newfmt/types.go`, then in `util/process-doc` run `make install`.\n\n")
	}

	f, err := parser.ParseFile(
		fset,
		"<stdin>",
		os.Stdin,
		parser.ParseComments|parser.SkipObjectResolution,
	)
	if err != nil {
		log.Fatal(err)
	}

	var printedTypeHeading bool
	for _, d := range f.Decls {
		if item, ok := d.(*ast.GenDecl); ok {
			switch item.Tok {
			case token.CONST:
				if item.Lparen.IsValid() {
					for _, s := range item.Specs {
						handleConst(s.(*ast.ValueSpec), nil)
					}
				} else {
					handleConst(item.Specs[0].(*ast.ValueSpec), item.Doc)
				}
			case token.TYPE:
				if item.Lparen.IsValid() {
					fail(item, "Parenthesized types not supported")
				}
				if len(item.Specs) != 1 {
					fail(item, "Unexpected structure")
				}
				td := item.Specs[0].(*ast.TypeSpec)
				name := td.Name.Name
				if *makeDoc && (name == "_preamble" || name == "_postamble") {
					printDoc(item, item.Doc)
				} else {
					if *makeDoc && !printedTypeHeading {
						fmt.Print("## Data types\n\n")
						printedTypeHeading = true
					}
					if st, ok := td.Type.(*ast.StructType); ok {
						handleStructType(item, td, st)
					} else {
						handleTypeAlias(item, td)
					}
				}
			}
		}
	}
}

func handleConst(v *ast.ValueSpec, d *ast.CommentGroup) {
	if *makeRust {
		if len(v.Names) != 1 || len(v.Values) != 1 {
			fail(v, "Unexpected constant form")
		}
		name := transformName(v.Names[0].Name)
		value := v.Values[0].(*ast.BasicLit).Value
		ty := "u64"
		if strings.HasPrefix(value, "\"") {
			ty = "&str"
		}
		fmt.Printf("pub const %s: %s = %s;\n", name, ty, value)
	}
}

// Probably there's some non-regexp way of doing this
var jsonRe = regexp.MustCompile(`json:"(.*)"`)

func handleStructType(item *ast.GenDecl, td *ast.TypeSpec, st *ast.StructType) {
	currType := td.Name.Name
	if *makeDoc {
		fmt.Printf("### Type: `%s`\n\n", currType)
		printDoc(item, item.Doc)
	}
	for _, f := range st.Fields.List {
		if len(f.Names) != 1 {
			fail(f, "Exactly one field name is required")
		}
		fname := f.Names[0].Name
		ftype := typeName(f.Type)
		if f.Tag == nil {
			fail(f, "Field tag missing")
		}
		m := jsonRe.FindStringSubmatch(f.Tag.Value)
		if m == nil {
			fail(f, "Field tag malformed - no json?")
		}
		fjson := m[1]
		switch {
		case *makeDoc:
			fmt.Printf("#### **`%s`** %s\n\n", fjson, ftype)
			printDoc(f, f.Doc)
		case *makeRust:
			// TODO: These are emitted as &str now.  But in a future universe, once all the old
			// formatting code is gone, or maybe even before, they could maybe be of a distinguished
			// type, to prevent literal strings from being used at all.  (It could be an enum wrapping a
			// &str, modulo problems with initialization, or maybe it would be an enum whose value
			// points into some table.)
			fmt.Printf(
				"pub const %s: &str = \"%s\"; // %s\n",
				transformName(currType+fname),
				fjson,
				ftype,
			)
		}
	}
}

func handleTypeAlias(item *ast.GenDecl, td *ast.TypeSpec) {
	if *makeDoc {
		fmt.Printf("### Type: `%s`\n\n", td.Name.Name)
		printDoc(item, item.Doc)
	}
}

func printDoc(ctx ast.Node, d *ast.CommentGroup) {
	if d == nil {
		warn(ctx, "No documentation")
	} else {
		var todo bool
		for _, c := range d.List {
			doc := c.Text
			ndoc := strings.TrimPrefix(doc, "// ")
			if ndoc == doc {
				ndoc = strings.TrimPrefix(doc, "//")
			}
			if !todo && strings.Index(ndoc, "TODO") >= 0 {
				warn(ctx, "TODO in comment")
				todo = true
			}
			fmt.Println(ndoc)
		}
		fmt.Println()
	}
}

func typeName(t ast.Expr) string {
	switch item := t.(type) {
	case *ast.Ident:
		return item.Name
	case *ast.StarExpr:
		return "*" + typeName(item.X)
	case *ast.ArrayType:
		if item.Len != nil {
			fail(item, "Array, not slice type")
		}
		return "[]" + typeName(item.Elt)
	default:
		fail(t, fmt.Sprint("Unmanaged type %#v", t))
		return "*bad*"
	}
}

func warn(x ast.Node, msg string) {
	if *warnings {
		p := x.Pos()
		file := fset.File(p)
		log.Printf("%s:%d: %s", file.Name(), file.Line(p), msg)
	}
}

func fail(x ast.Node, msg string) {
	p := x.Pos()
	file := fset.File(p)
	log.Fatalf("%s:%d: %s", file.Name(), file.Line(p), msg)
}

// Rust naming conventions: In a given name, the first capital letter X after a lower case
// letter is transformed to _X.
//
// TODO: _ should be inserted between the last two capitals of a run of capitals immediately
// followed by a lower case letter, so that 'CEClock' becomes '_CE_CLOCK_' no '_CECLOCK_'.

func transformName(n string) string {
	bs := []byte(n)
	name := ""
	for i := range bs {
		if i > 0 && isUpper(bs[i]) && !isUpper(bs[i-1]) {
			name += "_"
		}
		name += toUpper(bs[i])
	}
	return name
}

func isUpper(b uint8) bool {
	return b >= 'A' && b <= 'Z'
}

func isLower(b uint8) bool {
	return b >= 'a' && b <= 'z'
}

func toUpper(b uint8) string {
	if isLower(b) {
		return string(b - ('a' - 'A'))
	}
	return string(b)
}
